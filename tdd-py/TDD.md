# preface
## reasons for TDD
- predictable way to develop (you know, when you are finished)
- learn all lessons that code may teach you
- improves user experience
- provides confidence/trust, you in team and team in you
- feels good to write that way

## rules:
- you may only write any line of productive code if an automated test has failed
- eliminate duplication

## technical implications:
- design organically with code giving you feedback about (design) decisions
- we must write our own tests, nobody else will write them (in the time you need them)
- dev environment must be able to rapidly respond to small changes
- design must follow: high cohersion, low coupling -> makes testing easy

## tasks:
- Red - write a failing test
- Green - make your tests work
- Refactor - Eliminate duplication

